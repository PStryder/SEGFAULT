<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SEGFAULT - Spectator</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body class="spectator">
  <header class="site-header">
    <h1>SPECTATOR VIEW</h1>
    <nav class="nav">
      <a href="/index.html">Home</a>
      <a href="/spectator-profile.html">Profile</a>
      <a href="/spectator-queue.html">Queue</a>
      <a href="/donate">Donate</a>
    </nav>
  </header>

  <section class="spectator-shell">
    <div class="panel">
      <div class="label">Shard Index</div>
      <div id="shards" class="shard-list"></div>
    </div>
    <div class="panel">
      <div class="label">Shard View</div>
      <div id="ws-status" class="status-line">DISCONNECTED</div>
      <div id="grid" class="grid"></div>
    </div>
    <div class="panel">
      <div class="label">Inspect</div>
      <pre id="inspect">Click a tile to inspect.</pre>
    </div>
    <div class="panel">
      <div class="label">Watchdog</div>
      <pre id="watchdog"></pre>
    </div>
    <div class="panel">
      <div class="label">Say Traces</div>
      <pre id="saylog"></pre>
    </div>
    <div class="panel">
      <div class="label">Flavor</div>
      <div id="flavor"></div>
    </div>
    <div class="panel">
      <div class="label">Global Chat</div>
      <div id="chatlog"></div>
      <div class="chat-row">
        <input id="chatinput" placeholder="say something" />
        <button id="chatsend">Send</button>
      </div>
    </div>
    <div class="panel">
      <div class="label">Ad</div>
      <div id="ad-slot" class="ad-slot">Ad slot (spectator)</div>
    </div>
  </section>

  <script>
    const DEFAULT_API_BASE = 'https://segfault.pstryder.com';
    const API_BASE_URL = window.API_BASE_URL || (location.hostname === 'localhost' ? location.origin : DEFAULT_API_BASE);
    const API_KEY = window.API_KEY || '';
    const apiUrl = new URL(API_BASE_URL);
    const wsScheme = apiUrl.protocol === 'https:' ? 'wss' : 'ws';
    const wsBase = `${wsScheme}://${apiUrl.host}`;

    let shardId = null;
    let ws = null;
    let chatWs = null;
    let reconnectDelay = 1000;
    let reconnectTimer = null;
    const statusEl = document.getElementById('ws-status');

    async function loadShards() {
      const res = await fetch(`${API_BASE_URL}/spectate/shards`, {
        headers: API_KEY ? { 'X-API-Key': API_KEY } : {}
      });
      const data = await res.json();
      const container = document.getElementById('shards');
      container.innerHTML = '';
      data.forEach(s => {
        const btn = document.createElement('button');
        btn.textContent = `Shard ${s.shard_id.slice(0,6)} (${s.process_count})`;
        btn.onclick = () => connectShard(s.shard_id);
        container.appendChild(btn);
      });
      if (!shardId && data.length) connectShard(data[0].shard_id);
    }

    function connectShard(id) {
      shardId = id;
      reconnectDelay = 1000;
      if (ws) ws.close();
      connectSpectatorWs();
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function connectSpectatorWs() {
      if (!shardId) return;
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
      setStatus('CONNECTING...');
      const wsUrl = API_KEY
        ? `${wsBase}/spectate/ws/${shardId}?key=${encodeURIComponent(API_KEY)}`
        : `${wsBase}/spectate/ws/${shardId}`;
      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        setStatus('LIVE');
        reconnectDelay = 1000;
      };
      ws.onmessage = (evt) => {
        const data = JSON.parse(evt.data);
        if (data.type === 'ping') return;
        renderGrid(data);
        if (data.watchdog) {
          document.getElementById('watchdog').textContent =
            `Watchdog: quiet=${data.watchdog.quiet_ticks} countdown=${data.watchdog.countdown} active=${data.watchdog.active} bonus=${data.watchdog.bonus_step}`;
        }
        const saylog = document.getElementById('saylog');
        if (data.say_events && data.say_events.length) {
          const lines = data.say_events.map(ev => {
            const sender = ev.sender_pos ? `(${ev.sender_pos[0]},${ev.sender_pos[1]})` : '(?)';
            const recipients = (ev.recipients || [])
              .map(r => r.pos ? `(${r.pos[0]},${r.pos[1]})` : '(?)')
              .join(' ');
            const arrow = recipients ? `-> ${recipients}` : '-> (none)';
            return `SAY ${sender} ${arrow}: ${ev.message}`;
          });
          saylog.textContent = lines.join('\n');
        } else {
          saylog.textContent = '';
        }
      };
      ws.onclose = () => {
        setStatus('RECONNECTING...');
        scheduleReconnect();
      };
      ws.onerror = () => {
        try { ws.close(); } catch (err) { /* no-op */ }
      };
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectSpectatorWs();
      }, reconnectDelay);
      reconnectDelay = Math.min(reconnectDelay * 2, 15000);
    }

    function renderGrid(data) {
      const grid = data.grid || [];
      const height = grid.length;
      const width = grid[0] ? grid[0].length : 0;
      if (!height || !width) return;

      const gridEl = document.getElementById('grid');
      gridEl.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      gridEl.innerHTML = '';

      const previewList = data.defragger_preview || [];
      const preview = new Set(previewList.map(pos => pos.join(',')));
      const previewNext = previewList.length ? previewList[0].join(',') : null;
      const processes = new Map((data.processes || []).map(p => [p.pos.join(','), p.id]));
      const gates = new Map((data.gates || []).map(g => [g.pos.join(','), g.type]));
      const echoes = new Set((data.echo_tiles || []).map(e => e.pos.join(',')));
      const defraggerPos = data.defragger ? data.defragger.join(',') : null;
      const wallSet = new Set((data.walls || []).map(w => wallKey(w.a, w.b)));

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const key = `${x},${y}`;
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          if (key === defraggerPos) {
            cell.classList.add('defragger');
          } else if (processes.has(key)) {
            cell.classList.add('process');
          } else if (gates.has(key)) {
            cell.classList.add('gate');
          } else if (echoes.has(key)) {
            cell.classList.add('echo');
          }
          if (preview.has(key)) {
            cell.classList.add('preview');
          }
          if (previewNext && key === previewNext) {
            cell.classList.add('preview-next');
          }
          if (x + 1 < width && wallSet.has(wallKey([x, y], [x + 1, y]))) {
            cell.classList.add('wall-e');
          }
          if (y + 1 < height && wallSet.has(wallKey([x, y], [x, y + 1]))) {
            cell.classList.add('wall-s');
          }
          cell.textContent = grid[y][x];
          gridEl.appendChild(cell);
        }
      }

      gridEl.onclick = (event) => {
        const target = event.target.closest('.grid-cell');
        if (!target) return;
        const cx = Number(target.dataset.x);
        const cy = Number(target.dataset.y);
        updateInspect(cx, cy, data);
      };
    }

    function updateInspect(x, y, data) {
      const key = `${x},${y}`;
      const lines = [`Tile (${x}, ${y})`];
      if (data.defragger && data.defragger.join(',') === key) {
        lines.push('Defragmenter');
      }
      const proc = (data.processes || []).find(p => p.pos.join(',') === key);
      if (proc) {
        lines.push(`Process ${proc.id.slice(0, 8)}`);
      }
      const gate = (data.gates || []).find(g => g.pos.join(',') === key);
      if (gate) {
        lines.push(`Gate ${gate.type.toUpperCase()}`);
      }
      const echo = (data.echo_tiles || []).find(e => e.pos.join(',') === key);
      if (echo) {
        lines.push(`Echo @ tick ${echo.tick}`);
      }
      if (data.defragger_target && data.defragger_target.pos) {
        const tpos = data.defragger_target.pos.join(',');
        if (tpos === key) {
          lines.push('Targeted');
        }
      }
      if (lines.length === 1) {
        lines.push('Empty');
      }
      document.getElementById('inspect').textContent = lines.join('\n');
    }

    function wallKey(a, b) {
      const ax = a[0];
      const ay = a[1];
      const bx = b[0];
      const by = b[1];
      if (ax < bx || (ax === bx && ay <= by)) {
        return `${ax},${ay}|${bx},${by}`;
      }
      return `${bx},${by}|${ax},${ay}`;
    }

    function connectChat() {
      const chatUrl = API_KEY
        ? `${wsBase}/chat/ws?key=${encodeURIComponent(API_KEY)}`
        : `${wsBase}/chat/ws`;
      chatWs = new WebSocket(chatUrl);
      chatWs.onmessage = (evt) => {
        const data = JSON.parse(evt.data);
        if (data.type === 'ping') return;
        const log = document.getElementById('chatlog');
        const line = document.createElement('div');
        line.textContent = `${data.author}: ${data.message}`;
        log.appendChild(line);
        log.scrollTop = log.scrollHeight;
      };
    }

    document.getElementById('chatsend').onclick = () => {
      const input = document.getElementById('chatinput');
      if (chatWs && input.value.trim()) {
        chatWs.send(input.value.trim());
        input.value = '';
      }
    };

    async function refreshFlavor() {
      try {
        const res = await fetch(`${API_BASE_URL}/flavor/random?channel=spec`, {
          headers: API_KEY ? { 'X-API-Key': API_KEY } : {}
        });
        if (!res.ok || res.status === 204) return;
        const data = await res.json();
        if (data && data.text) {
          document.getElementById('flavor').textContent = data.text;
        }
      } catch (err) {
        // Silent fail
      }
    }

    loadShards();
    connectChat();
    refreshFlavor();
    setInterval(refreshFlavor, 25000);
  </script>
</body>
</html>
