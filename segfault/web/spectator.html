<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <title>SEGFAULT - Spectator</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8459855832719855"
     crossorigin="anonymous"></script>
</head>
<body class="spectator">
  <header class="site-header">
    <h1>SPECTATOR VIEW</h1>
    <nav class="nav">
      <a href="/">Home</a>
      <a href="/spectator/queue">Queue</a>
      <a href="/replay">Replay</a>
      <a href="/donate">Donate</a>
    </nav>
  </header>

  <section class="spectator-shell">
    <div class="panel shard-index">
      <div class="label">Shard Index</div>
      <div id="shards" class="shard-list"></div>
    </div>
    <div class="spectator-main">
      <div class="spectator-row">
        <div class="panel shard-panel">
          <div class="label">Shard View</div>
          <div id="ws-status" class="status-line">DISCONNECTED</div>
          <div id="grid" class="grid"></div>
        </div>
        <div class="panel chat-panel">
          <div class="label">Global Chat</div>
          <div id="chatlog"></div>
          <div class="chat-row">
            <input id="chatinput" placeholder="say something" />
            <button id="chatsend">Send</button>
          </div>
        </div>
      </div>
      <div class="spectator-bottom">
        <div class="panel traces-panel">
          <div class="label">Say Traces</div>
          <div id="saylog" class="trace-log"></div>
        </div>
        <div class="panel ad-panel">
          <div class="label ad-label">Ad</div>
          <div id="ad-slot" class="ad-slot">Ad slot</div>
        </div>
      </div>
    </div>
  </section>

  <div id="inspect-tooltip" class="inspect-tooltip" role="status" aria-live="polite"></div>

  <script>
    const DEFAULT_API_BASE = 'https://api.segfault.pstryder.com';
    const API_BASE_URL = window.API_BASE_URL || (location.hostname === 'localhost' ? location.origin : DEFAULT_API_BASE);
    const API_KEY = window.API_KEY || '';
    const apiUrl = new URL(API_BASE_URL);
    const wsScheme = apiUrl.protocol === 'https:' ? 'wss' : 'ws';
    const wsBase = `${wsScheme}://${apiUrl.host}`;

    let shardId = null;
    let ws = null;
    let chatWs = null;
    let reconnectDelay = 1000;
    let reconnectTimer = null;
    const statusEl = document.getElementById('ws-status');
    const chatLogEl = document.getElementById('chatlog');
    const sayLogEl = document.getElementById('saylog');
    let lastTick = null;
    let lastWatchdogTick = null;
    const TICK_MS = 10000;
    const DEFRAGGER_REVEAL_MS = TICK_MS / 2;
    let defraggerRevealed = true; // true on first load (no delay)
    let defraggerRevealTimer = null;
    let currentFullData = null;
    const seenSayEvents = new Set();
    const seenSayOrder = [];
    const seenBroadcasts = new Set();
    const seenBroadcastOrder = [];
    const MAX_SEEN = 500;

    async function loadShards() {
      try {
        const res = await fetch(`${API_BASE_URL}/spectate/shards`, {
          headers: API_KEY ? { 'X-API-Key': API_KEY } : {}
        });
        const data = await res.json();
        const container = document.getElementById('shards');
        container.innerHTML = '';
        let currentShardExists = false;
        data.forEach(s => {
          const btn = document.createElement('button');
          btn.textContent = `Shard ${s.shard_id.slice(0,6)} (${s.process_count})`;
          btn.onclick = () => connectShard(s.shard_id);
          if (shardId && s.shard_id === shardId) {
            btn.classList.add('active');
            currentShardExists = true;
          }
          container.appendChild(btn);
        });
        // Only auto-connect if no shard selected, or current shard was deleted
        if ((!shardId || !currentShardExists) && data.length) {
          connectShard(data[0].shard_id);
        }
      } catch (err) {
        // Silent fail - will retry on next tick
      }
    }

    function connectShard(id) {
      shardId = id;
      reconnectDelay = 1000;
      if (ws) ws.close();
      fetchShardSnapshot();
      connectSpectatorWs();
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function connectSpectatorWs() {
      if (!shardId) return;
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
      setStatus('CONNECTING...');
      const wsUrl = API_KEY
        ? `${wsBase}/spectate/ws/${shardId}?key=${encodeURIComponent(API_KEY)}`
        : `${wsBase}/spectate/ws/${shardId}`;
      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        setStatus('LIVE');
        reconnectDelay = 1000;
        fetchShardSnapshot();
      };
      ws.onmessage = (evt) => {
        const data = JSON.parse(evt.data);
        if (data.type === 'ping') return;
        handleSpectatorData(data);
      };
      ws.onclose = () => {
        setStatus('RECONNECTING...');
        scheduleReconnect();
      };
      ws.onerror = () => {
        try { ws.close(); } catch (err) { /* no-op */ }
      };
    }

    async function fetchShardSnapshot() {
      if (!shardId) return;
      try {
        const res = await fetch(`${API_BASE_URL}/spectate/shard/${shardId}`, {
          headers: API_KEY ? { 'X-API-Key': API_KEY } : {}
        });
        if (!res.ok) return;
        const data = await res.json();
        handleSpectatorData(data);
      } catch (err) {
        // No-op: WS will update when it lands
      }
    }

    function handleSpectatorData(data) {
      currentFullData = data;
      if (data && typeof data.tick === 'number') {
        if (lastTick !== null && data.tick !== lastTick) {
          // New tick: hide defragger, schedule reveal
          defraggerRevealed = false;
          if (defraggerRevealTimer) clearTimeout(defraggerRevealTimer);
          defraggerRevealTimer = setTimeout(revealDefragger, DEFRAGGER_REVEAL_MS);
          refreshFlavor();
          loadShards();
        }
        lastTick = data.tick;
      }
      renderGrid(data);
      if (data.watchdog && typeof data.tick === 'number' && data.tick !== lastWatchdogTick) {
        appendSayTrace(
          `[SYSTEM] Watchdog: quiet=${data.watchdog.quiet_ticks} countdown=${data.watchdog.countdown} active=${data.watchdog.active} bonus=${data.watchdog.bonus_step}`
        );
        lastWatchdogTick = data.tick;
      }
      if (data.say_events && data.say_events.length) {
        data.say_events.forEach(ev => {
          const sender = ev.sender_pos ? `(${ev.sender_pos[0]},${ev.sender_pos[1]})` : '(?)';
          const recipients = (ev.recipients || [])
            .map(r => r.pos ? `(${r.pos[0]},${r.pos[1]})` : '(?)')
            .join(' ');
          const arrow = recipients ? `-> ${recipients}` : '-> (none)';
          const key = `S|${ev.tick}|${ev.sender_id}|${ev.message}|${recipients}`;
          if (recordSeen(key, seenSayEvents, seenSayOrder)) {
            appendSayTrace(`SAY ${sender} ${arrow}: ${ev.message}`);
          }
        });
      }
      if (data.broadcasts && data.broadcasts.length) {
        data.broadcasts.forEach(ev => {
          const tick = typeof data.tick === 'number' ? data.tick : 0;
          const key = `B|${tick}|${ev.process_id}|${ev.timestamp_ms}|${ev.message}`;
          if (recordSeen(key, seenBroadcasts, seenBroadcastOrder)) {
            appendSayTrace(`BCAST ${ev.process_id.slice(0, 8)}: ${ev.message}`);
          }
        });
      }
    }

    function recordSeen(key, seenSet, seenOrder) {
      if (seenSet.has(key)) {
        return false;
      }
      seenSet.add(key);
      seenOrder.push(key);
      if (seenOrder.length > MAX_SEEN) {
        const oldest = seenOrder.shift();
        if (oldest) {
          seenSet.delete(oldest);
        }
      }
      return true;
    }

    function isNearBottom(el) {
      const threshold = 24;
      return el.scrollHeight - el.scrollTop - el.clientHeight <= threshold;
    }

    function appendChatLine(text) {
      const shouldScroll = isNearBottom(chatLogEl);
      const line = document.createElement('div');
      line.textContent = text;
      chatLogEl.appendChild(line);
      if (shouldScroll) {
        chatLogEl.scrollTop = chatLogEl.scrollHeight;
      }
    }

    function appendSayTrace(text) {
      const shouldScroll = isNearBottom(sayLogEl);
      const line = document.createElement('div');
      line.textContent = text;
      sayLogEl.appendChild(line);
      if (shouldScroll) {
        sayLogEl.scrollTop = sayLogEl.scrollHeight;
      }
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectSpectatorWs();
      }, reconnectDelay);
      reconnectDelay = Math.min(reconnectDelay * 2, 15000);
    }

    function revealDefragger() {
      defraggerRevealed = true;
      if (currentFullData) renderGrid(currentFullData);
    }

    function renderGrid(data) {
      const grid = data.grid || [];
      const height = grid.length;
      const width = grid[0] ? grid[0].length : 0;
      if (!height || !width) return;

      const gridEl = document.getElementById('grid');
      gridEl.style.gridTemplateColumns = `repeat(${width}, var(--cell-size))`;
      gridEl.style.setProperty('--grid-size', width);
      gridEl.innerHTML = '';
      hideTooltip();

      const previewList = defraggerRevealed ? (data.defragger_preview || []) : [];
      const preview = new Set(previewList.map(pos => pos.join(',')));
      const previewNext = previewList.length ? previewList[0].join(',') : null;
      const processes = new Map((data.processes || []).map(p => [p.pos.join(','), p.id]));
      const gates = new Map((data.gates || []).map(g => [g.pos.join(','), g.type]));
      const echoes = new Set((data.echo_tiles || []).map(e => e.pos.join(',')));
      const defraggerPos = data.defragger ? data.defragger.join(',') : null;
      const wallSet = new Set((data.walls || []).map(w => wallKey(w.a, w.b)));

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const key = `${x},${y}`;
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          if (key === defraggerPos) {
            cell.classList.add('defragger');
          } else if (processes.has(key)) {
            cell.classList.add('process');
          } else if (gates.has(key)) {
            cell.classList.add('gate');
          } else if (echoes.has(key)) {
            cell.classList.add('echo');
          }
          if (preview.has(key)) {
            cell.classList.add('preview');
          }
          if (previewNext && key === previewNext) {
            cell.classList.add('preview-next');
          }
          if (x + 1 < width && wallSet.has(wallKey([x, y], [x + 1, y]))) {
            cell.classList.add('wall-e');
          }
          if (y + 1 < height && wallSet.has(wallKey([x, y], [x, y + 1]))) {
            cell.classList.add('wall-s');
          }
          cell.textContent = grid[y][x];
          gridEl.appendChild(cell);
        }
      }

      gridEl.onclick = (event) => {
        const target = event.target.closest('.grid-cell');
        if (!target) return;
        const cx = Number(target.dataset.x);
        const cy = Number(target.dataset.y);
        showTooltipForTile(cx, cy, data, target);
      };
    }

    function showTooltipForTile(x, y, data, anchorEl) {
      const key = `${x},${y}`;
      const lines = [`Tile (${x}, ${y})`];
      if (defraggerRevealed && data.defragger && data.defragger.join(',') === key) {
        lines.push('Defragmenter');
        if (typeof data.total_kills === 'number') {
          lines.push(`PIDs TERM: ${data.total_kills}`);
        }
      }
      const proc = (data.processes || []).find(p => p.pos.join(',') === key);
      if (proc) {
        lines.push(`Process ${proc.id.slice(0, 8)}`);
      }
      const gate = (data.gates || []).find(g => g.pos.join(',') === key);
      if (gate) {
        lines.push(`Gate ${gate.type.toUpperCase()}`);
      }
      const echo = (data.echo_tiles || []).find(e => e.pos.join(',') === key);
      if (echo) {
        lines.push(`Echo @ tick ${echo.tick}`);
      }
      if (data.defragger_target && data.defragger_target.pos) {
        const tpos = data.defragger_target.pos.join(',');
        if (tpos === key) {
          lines.push('Targeted');
        }
      }
      if (lines.length === 1) {
        hideTooltip();
        return;
      }
      renderTooltip(lines, anchorEl);
    }

    const tooltipEl = document.getElementById('inspect-tooltip');

    function renderTooltip(lines, anchorEl) {
      tooltipEl.textContent = lines.join('\n');
      tooltipEl.style.display = 'block';
      const rect = anchorEl.getBoundingClientRect();
      const padding = 8;
      let left = rect.right + padding;
      let top = rect.top;
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      const tipRect = tooltipEl.getBoundingClientRect();
      if (tipRect.right > window.innerWidth - padding) {
        left = rect.left - tipRect.width - padding;
      }
      if (left < padding) {
        left = padding;
      }
      if (tipRect.bottom > window.innerHeight - padding) {
        top = Math.max(padding, window.innerHeight - tipRect.height - padding);
      }
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
    }

    function hideTooltip() {
      tooltipEl.style.display = 'none';
    }

    document.addEventListener('click', (event) => {
      if (event.target.closest('.grid-cell')) return;
      hideTooltip();
    });

    function wallKey(a, b) {
      const ax = a[0];
      const ay = a[1];
      const bx = b[0];
      const by = b[1];
      if (ax < bx || (ax === bx && ay <= by)) {
        return `${ax},${ay}|${bx},${by}`;
      }
      return `${bx},${by}|${ax},${ay}`;
    }

    function connectChat() {
      const chatUrl = API_KEY
        ? `${wsBase}/chat/ws?key=${encodeURIComponent(API_KEY)}`
        : `${wsBase}/chat/ws`;
      chatWs = new WebSocket(chatUrl);
      chatWs.onmessage = (evt) => {
        const data = JSON.parse(evt.data);
        if (data.type === 'ping') return;
        appendChatLine(`${data.author}: ${data.message}`);
      };
    }

    document.getElementById('chatsend').onclick = () => {
      const input = document.getElementById('chatinput');
      if (chatWs && input.value.trim()) {
        chatWs.send(input.value.trim());
        input.value = '';
      }
    };

    document.getElementById('chatinput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('chatsend').click();
      }
    });

    async function refreshFlavor() {
      try {
        const res = await fetch(`${API_BASE_URL}/flavor/random?channel=spec`, {
          headers: API_KEY ? { 'X-API-Key': API_KEY } : {}
        });
        if (!res.ok || res.status === 204) return;
        const data = await res.json();
        if (data && data.text) {
          appendChatLine(`[SYSTEM] ${data.text}`);
        }
      } catch (err) {
        // Silent fail
      }
    }

    loadShards();
    connectChat();
  </script>
<script src="/static/ad-label.js"></script>
</body>
</html>
