<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SEGFAULT - Replay</title>
  <link rel="stylesheet" href="/static/style.css" />
  <style>
    body.replay {
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    body.replay .spectator-shell {
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    body.replay .spectator-main {
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
      gap: 12px;
    }
    body.replay .spectator-row {
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    body.replay .spectator-row .panel {
      overflow-y: auto;
      margin-bottom: 0;
    }
    .replay-footer {
      flex-shrink: 0;
      padding: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
    }
    .replay-footer .ad-slot {
      margin: 0;
    }
  </style>
</head>
<body class="spectator replay">
  <header class="site-header">
    <h1>REPLAY ARCHIVE</h1>
    <nav class="nav">
      <a href="/">Home</a>
      <a href="/spectator">Spectate</a>
      <a href="/spectator/queue">Queue</a>
      <a href="/donate">Donate</a>
    </nav>
  </header>

  <section class="spectator-shell">
    <div class="panel shard-index">
      <div class="label">Replay Shards</div>
      <div id="replay-list" class="shard-list"></div>
    </div>
    <div class="spectator-main">
      <div class="spectator-row">
        <div class="panel shard-panel">
          <div class="label">Replay View</div>
          <div id="tick-display" class="status-line">Tick 0</div>
          <div id="grid" class="grid"></div>
          <div id="target-reason" class="status-line"></div>
          <div class="label" style="margin-top: 12px;">Say Traces</div>
          <div id="saylog" class="trace-log" style="flex: 1; overflow-y: auto; min-height: 80px;"></div>
        </div>
        <div class="panel controls-panel">
          <div class="label">Playback Controls</div>
          <div class="controls">
            <div class="chat-row">
              <button id="play">Play</button>
              <button id="pause">Pause</button>
              <button id="step-back">Step -</button>
              <button id="step-forward">Step +</button>
            </div>
            <div class="chat-row">
              <span>Speed</span>
              <button class="speed" data-speed="0.5">0.5x</button>
              <button class="speed active" data-speed="1">1x</button>
              <button class="speed" data-speed="2">2x</button>
              <button class="speed" data-speed="4">4x</button>
            </div>
            <div class="chat-row">
              <input id="scrubber" type="range" min="0" max="0" value="0" />
            </div>
          </div>
          <div class="label" style="margin-top: 12px;">Events</div>
          <div id="event-log" class="trace-log" style="flex: 1; min-height: 80px;"></div>
        </div>
      </div>
      <footer class="replay-footer">
        <div id="ad-slot" class="ad-slot">Ad slot (replay)</div>
      </footer>
    </div>
  </section>

  <div id="inspect-tooltip" class="inspect-tooltip" role="status" aria-live="polite"></div>

  <script>
    const DEFAULT_API_BASE = 'https://api.segfault.pstryder.com';
    const API_BASE_URL = window.API_BASE_URL || (location.hostname === 'localhost' ? location.origin : DEFAULT_API_BASE);
    const API_KEY = window.API_KEY || '';
    const TICK_SECONDS = 10;
    const CHUNK_SIZE = 100;
    const SHARD_PAGE_SIZE = 50;

    const replayListEl = document.getElementById('replay-list');
    const gridEl = document.getElementById('grid');
    const tickDisplayEl = document.getElementById('tick-display');
    const scrubberEl = document.getElementById('scrubber');
    const eventLogEl = document.getElementById('event-log');
    const saylogEl = document.getElementById('saylog');
    const targetReasonEl = document.getElementById('target-reason');
    const tooltipEl = document.getElementById('inspect-tooltip');

    let selectedShard = null;
    let shardMeta = {};
    let allShards = [];
    let shardsLoaded = 0;
    let shardsHasMore = true;
    let shardsLoading = false;

    class ReplayPlayer {
      constructor() {
        this.shardId = null;
        this.tickMap = new Map();
        this.loadedUntil = -1;
        this.hasMore = true;
        this.loading = false;
        this.currentTick = 0;
        this.totalTicks = 0;
        this.playing = false;
        this.speed = 1.0;
        this.intervalId = null;
      }

      async loadShard(shardId, totalTicks) {
        this.pause();
        this.shardId = shardId;
        this.tickMap.clear();
        this.loadedUntil = -1;
        this.hasMore = true;
        this.loading = false;
        this.currentTick = 0;
        this.totalTicks = totalTicks || 0;
        scrubberEl.max = this.totalTicks;
        scrubberEl.value = 0;
        await this.loadNextChunk();
        await this.ensureTickLoaded(this.currentTick);
        renderCurrent();
      }

      async loadNextChunk() {
        if (!this.shardId || this.loading || !this.hasMore) return;
        this.loading = true;
        const startTick = this.loadedUntil + 1;
        const url = `${API_BASE_URL}/replays/${this.shardId}?start_tick=${startTick}&limit=${CHUNK_SIZE}`;
        const headers = API_KEY ? { 'X-API-Key': API_KEY } : {};
        const res = await fetch(url, { headers });
        if (!res.ok) {
          this.loading = false;
          return;
        }
        const data = await res.json();
        (data.ticks || []).forEach(entry => {
          this.tickMap.set(entry.tick, entry.snapshot);
          this.loadedUntil = Math.max(this.loadedUntil, entry.tick);
        });
        this.hasMore = data.has_more;
        this.loading = false;
      }

      async ensureTickLoaded(tick) {
        while (tick > this.loadedUntil && this.hasMore) {
          await this.loadNextChunk();
        }
      }

      play() {
        if (this.playing) return;
        this.playing = true;
        const interval = (TICK_SECONDS * 1000) / this.speed;
        this.intervalId = setInterval(() => {
          this.stepForward();
        }, interval);
      }

      pause() {
        this.playing = false;
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
        }
      }

      setSpeed(multiplier) {
        this.speed = multiplier;
        if (this.playing) {
          this.pause();
          this.play();
        }
      }

      async stepForward() {
        if (this.currentTick >= this.totalTicks) {
          this.pause();
          return;
        }
        this.currentTick += 1;
        await this.ensureTickLoaded(this.currentTick);
        renderCurrent();
        if (this.hasMore && this.currentTick >= this.loadedUntil - Math.floor(CHUNK_SIZE * 0.2)) {
          this.loadNextChunk();
        }
      }

      async stepBackward() {
        if (this.currentTick <= 0) return;
        this.currentTick -= 1;
        await this.ensureTickLoaded(this.currentTick);
        renderCurrent();
      }

      async seekTo(tick) {
        this.currentTick = Math.max(0, Math.min(tick, this.totalTicks));
        await this.ensureTickLoaded(this.currentTick);
        renderCurrent();
      }

      snapshot() {
        return this.tickMap.get(this.currentTick) || null;
      }
    }

    const player = new ReplayPlayer();

    async function loadReplayList(append = false) {
      if (shardsLoading || (!append && !shardsHasMore)) return;
      shardsLoading = true;

      const headers = API_KEY ? { 'X-API-Key': API_KEY } : {};
      const limit = append ? SHARD_PAGE_SIZE : Math.max(SHARD_PAGE_SIZE, shardsLoaded + SHARD_PAGE_SIZE);
      const res = await fetch(`${API_BASE_URL}/replays?limit=${limit}`, { headers });
      if (!res.ok) {
        shardsLoading = false;
        return;
      }
      const data = await res.json();
      const shards = data.shards || [];

      if (append) {
        // Append new shards that we haven't seen
        const newShards = shards.slice(shardsLoaded);
        allShards = allShards.concat(newShards);
        newShards.forEach(shard => renderShardButton(shard));
      } else {
        allShards = shards;
        replayListEl.innerHTML = '';
        shards.forEach(shard => renderShardButton(shard));
      }

      shardsLoaded = allShards.length;
      shardsHasMore = shards.length >= limit;
      shardsLoading = false;

      // Handle URL params on initial load
      if (!append) {
        const params = new URLSearchParams(window.location.search);
        const shardParam = params.get('shard');
        if (shardParam) {
          const match = allShards.find(s => s.shard_id === shardParam);
          if (match) {
            selectShard(match, Number(params.get('tick') || 0));
          }
        }
      }
    }

    function renderShardButton(shard) {
      const btn = document.createElement('button');
      const shortId = shard.shard_id.slice(0, 6);
      const end = shard.ended_at ? new Date(shard.ended_at * 1000).toLocaleString() : 'LIVE';
      btn.textContent = `${shortId} | T${shard.total_ticks} | P${shard.total_processes}`;
      btn.title = `Shard ${shard.shard_id}\nTicks: ${shard.total_ticks}\nProcesses: ${shard.total_processes}\nKills: ${shard.total_kills}\nSurvivals: ${shard.total_survivals}\nEnded: ${end}`;
      btn.onclick = () => selectShard(shard);
      if (selectedShard === shard.shard_id) {
        btn.classList.add('active');
      }
      btn.dataset.shardId = shard.shard_id;
      replayListEl.appendChild(btn);
    }

    function updateShardButtons() {
      replayListEl.querySelectorAll('button').forEach(btn => {
        if (btn.dataset.shardId === selectedShard) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // Infinite scroll for shard list
    replayListEl.addEventListener('scroll', () => {
      if (shardsLoading || !shardsHasMore) return;
      const { scrollTop, scrollHeight, clientHeight } = replayListEl;
      if (scrollHeight - scrollTop - clientHeight < 50) {
        loadReplayList(true);
      }
    });

    async function selectShard(shard, startTick = 0) {
      selectedShard = shard.shard_id;
      shardMeta = shard;
      updateShardButtons();
      await player.loadShard(shard.shard_id, shard.total_ticks || 0);
      if (startTick > 0) {
        await player.seekTo(startTick);
      }
      updateUrl();
    }

    function updateUrl() {
      if (!selectedShard) return;
      const params = new URLSearchParams();
      params.set('shard', selectedShard);
      params.set('tick', String(player.currentTick));
      const next = `${window.location.pathname}?${params.toString()}`;
      window.history.replaceState({}, '', next);
    }

    function renderCurrent() {
      scrubberEl.value = player.currentTick;
      tickDisplayEl.textContent = `Tick ${player.currentTick} / ${player.totalTicks}`;
      updateUrl();
      const snapshot = player.snapshot();
      if (!snapshot) {
        gridEl.textContent = 'Loading...';
        return;
      }
      renderGrid(snapshot);
      renderPanels(snapshot);
    }

    function renderGrid(snapshot) {
      const size = snapshot.grid_size || 20;
      gridEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      gridEl.style.setProperty('--grid-size', size);
      gridEl.innerHTML = '';
      hideTooltip();

      const wallSet = new Set((snapshot.walls || []).map(w => wallKey([w[0], w[1]], [w[2], w[3]])));
      const processMap = new Map((snapshot.processes || []).map(p => [p.pos.join(','), p]));
      const gateMap = new Map((snapshot.gates || []).map(g => [g.pos.join(','), g.type]));
      const echoSet = new Set((snapshot.echo_tiles || []).map(e => e.pos.join(',')));
      const defraggerPos = snapshot.defragger && snapshot.defragger.pos ? snapshot.defragger.pos.join(',') : null;
      const targetId = snapshot.defragger && snapshot.defragger.target_id ? snapshot.defragger.target_id : null;
      let targetPos = null;
      if (targetId) {
        const target = (snapshot.processes || []).find(p => p.id === targetId);
        if (target) targetPos = target.pos.join(',');
      }

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const key = `${x},${y}`;
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          if (key === defraggerPos) {
            cell.classList.add('defragger');
          } else if (processMap.has(key)) {
            cell.classList.add('process');
          } else if (gateMap.has(key)) {
            cell.classList.add('gate');
          } else if (echoSet.has(key)) {
            cell.classList.add('echo');
          }
          if (targetPos && key === targetPos) {
            cell.classList.add('target');
          }
          if (x + 1 < size && wallSet.has(wallKey([x, y], [x + 1, y]))) {
            cell.classList.add('wall-e');
          }
          if (y + 1 < size && wallSet.has(wallKey([x, y], [x, y + 1]))) {
            cell.classList.add('wall-s');
          }
          cell.textContent = '.';
          gridEl.appendChild(cell);
        }
      }

      gridEl.onclick = (event) => {
        const target = event.target.closest('.grid-cell');
        if (!target) return;
        const cx = Number(target.dataset.x);
        const cy = Number(target.dataset.y);
        showTooltipForTile(cx, cy, snapshot, target);
      };
    }

    function showTooltipForTile(x, y, snapshot, anchorEl) {
      const key = `${x},${y}`;
      const lines = [`Tile (${x}, ${y})`];
      const defraggerPos = snapshot.defragger && snapshot.defragger.pos ? snapshot.defragger.pos.join(',') : null;
      if (defraggerPos === key) {
        lines.push('Defragmenter');
      }
      const proc = (snapshot.processes || []).find(p => p.pos.join(',') === key);
      if (proc) {
        lines.push(`Process ${proc.id.slice(0, 8)}`);
        lines.push(`Call sign: ${proc.call_sign}`);
        lines.push(proc.alive ? 'ALIVE' : 'DEAD');
      }
      const gate = (snapshot.gates || []).find(g => g.pos.join(',') === key);
      if (gate) {
        lines.push(`Gate ${gate.type.toUpperCase()}`);
      }
      const echo = (snapshot.echo_tiles || []).find(e => e.pos.join(',') === key);
      if (echo) {
        lines.push(`Echo @ tick ${echo.tick}`);
      }
      if (lines.length === 1) {
        hideTooltip();
        return;
      }
      renderTooltip(lines, anchorEl);
    }

    function renderTooltip(lines, anchorEl) {
      tooltipEl.textContent = lines.join('\n');
      tooltipEl.style.display = 'block';
      const rect = anchorEl.getBoundingClientRect();
      const padding = 8;
      let left = rect.right + padding;
      let top = rect.top;
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      const tipRect = tooltipEl.getBoundingClientRect();
      if (tipRect.right > window.innerWidth - padding) {
        left = rect.left - tipRect.width - padding;
      }
      if (left < padding) {
        left = padding;
      }
      if (tipRect.bottom > window.innerHeight - padding) {
        top = Math.max(padding, window.innerHeight - tipRect.height - padding);
      }
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
    }

    function hideTooltip() {
      tooltipEl.style.display = 'none';
    }

    document.addEventListener('click', (event) => {
      if (event.target.closest('.grid-cell')) return;
      hideTooltip();
    });

    function renderPanels(snapshot) {
      // Event log: tick events + broadcasts
      const eventLines = [];
      const events = snapshot.events || {};
      if (events.spawns && events.spawns.length) {
        eventLines.push(`SPAWN: ${events.spawns.join(' ')}`);
      }
      if (events.kills && events.kills.length) {
        eventLines.push(`KILL: ${events.kills.join(' ')}`);
      }
      if (events.survivals && events.survivals.length) {
        eventLines.push(`SURVIVE: ${events.survivals.join(' ')}`);
      }
      if (events.ghosts && events.ghosts.length) {
        eventLines.push(`GHOST: ${events.ghosts.join(' ')}`);
      }
      const broadcasts = snapshot.broadcasts || [];
      broadcasts.forEach(b => {
        eventLines.push(`BCAST [${b.process_id.slice(0, 6)}]: ${b.message}`);
      });
      eventLogEl.textContent = eventLines.length ? eventLines.join('\n') : '(no events)';

      // Say traces
      const sayEvents = snapshot.say_events || [];
      saylogEl.textContent = sayEvents.length
        ? sayEvents.map(ev => {
            const sender = ev.sender_pos ? `(${ev.sender_pos[0]},${ev.sender_pos[1]})` : '(?)';
            const recipients = (ev.recipients || [])
              .map(r => r.pos ? `(${r.pos[0]},${r.pos[1]})` : '(?)')
              .join(' ');
            const arrow = recipients ? `-> ${recipients}` : '-> (none)';
            return `SAY ${sender} ${arrow}: ${ev.message}`;
          }).join('\n')
        : '(no messages)';

      const reason = snapshot.defragger ? snapshot.defragger.target_reason : null;
      targetReasonEl.textContent = reason ? `Target: ${reason}` : '';
    }

    function wallKey(a, b) {
      const ax = a[0];
      const ay = a[1];
      const bx = b[0];
      const by = b[1];
      if (ax < bx || (ax === bx && ay <= by)) {
        return `${ax},${ay}|${bx},${by}`;
      }
      return `${bx},${by}|${ax},${ay}`;
    }

    document.getElementById('play').onclick = () => player.play();
    document.getElementById('pause').onclick = () => player.pause();
    document.getElementById('step-forward').onclick = () => player.stepForward();
    document.getElementById('step-back').onclick = () => player.stepBackward();
    scrubberEl.addEventListener('input', (e) => player.seekTo(Number(e.target.value)));
    document.querySelectorAll('.speed').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.speed').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        player.setSpeed(Number(btn.dataset.speed));
      });
    });

    loadReplayList();
  </script>
</body>
</html>
